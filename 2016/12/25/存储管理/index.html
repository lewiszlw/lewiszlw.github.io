<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="操作系统," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="存储器是计算机系统的重要资源之一。任何程序和数据及各种控制用的数据结构都必须占用一定的存储空间，因此，存储管理直接影响系统性能。">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="存储管理">
<meta property="og:url" content="http://zlw.poker/2016/12/25/存储管理/index.html">
<meta property="og:site_name" content="Lewis&#39;s Blog">
<meta property="og:description" content="存储器是计算机系统的重要资源之一。任何程序和数据及各种控制用的数据结构都必须占用一定的存储空间，因此，存储管理直接影响系统性能。">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%862.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%863.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%864.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%865.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%866.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%867.PNG">
<meta property="og:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%868.PNG">
<meta property="og:updated_time" content="2017-01-04T05:57:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="存储管理">
<meta name="twitter:description" content="存储器是计算机系统的重要资源之一。任何程序和数据及各种控制用的数据结构都必须占用一定的存储空间，因此，存储管理直接影响系统性能。">
<meta name="twitter:image" content="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861.PNG">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://zlw.poker/2016/12/25/存储管理/"/>


  <title> 存储管理 | Lewis's Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1260624965&web_id=1260624965" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lewis's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                存储管理
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-12-25T19:27:01+08:00" content="2016-12-25">
              2016-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
                  , 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书笔记/计算机操作系统教程/" itemprop="url" rel="index">
                    <span itemprop="name">计算机操作系统教程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/25/存储管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/25/存储管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
		  

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>存储器是计算机系统的重要资源之一。任何程序和数据及各种控制用的数据结构都必须占用一定的存储空间，因此，存储管理直接影响系统性能。<br><a id="more"></a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h2><p><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%861.PNG" alt="存储管理1"></p>
<ul>
<li>内存储器（内存、主存）<ul>
<li>CPU能直接访问的存储器</li>
<li>用来存放系统和用户的程序和数据，其特点是存取速度快，存储方式是以新换旧，断电信息丢失</li>
</ul>
</li>
<li>外存储器（外存、辅存）<ul>
<li>CPU不能直接访问的存储器</li>
<li>用来存放用户的各种信息，存取速度相对于内存要慢得多，但可用来长期保存用户信息</li>
</ul>
</li>
</ul>
<p>内存的物理组织</p>
<ul>
<li>内存地址：把内存分成若干个大小相等的存储单元，每个单元占8位，即1字节（byte）。每个存储单元给一个编号，称为内存地址（物理地址、绝对地址、实地址）。</li>
<li>内存地址空间：内存地址的集合称为内存地址空间（主存地址空间），它是一个一维的线性空间。</li>
</ul>
<p>程序的逻辑结构</p>
<ul>
<li>程序地址：用户编程时所用的地址。</li>
<li>程序地址空间：用户的程序地址的集合称为程序地址空间，它的编址总是从0开始的，可以是一维线性空间，也可以是多维空间。</li>
</ul>
<p>用户程序的主要处理阶段：</p>
<ul>
<li>编辑：形成源文件</li>
<li>编译：形成目标文件</li>
<li>链接：由多个目标文件或程序库生成可执行文件</li>
<li>装入：构造PCB，形成进程<br>程序必须装到内存才能运行，这需要根据内存的使用情况和分配策略，进行内存空间分配</li>
<li>运行：建立的进程获得CPU执行</li>
</ul>
<p>逻辑地址、物理地址和地址映射</p>
<ul>
<li>逻辑地址（相对地址，虚地址）：用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。<ul>
<li>其首地址为0，其余指令中的地址都相对于首地址来编址</li>
<li>不能用逻辑地址在内存中读取信息</li>
</ul>
</li>
<li>物理地址（绝对地址，实地址）：内存中存储单元的地址。物理地址可直接寻址。</li>
<li>地址映射：将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址。<ul>
<li>当程序装入内存时，操作系统为该程序分配一个内存空间，由于程序的逻辑地址与分配到的内存物理地址不一致, 而CPU执行指令时，是按物理地址进行的，所以需要进行地址转换。</li>
</ul>
</li>
</ul>
<h2 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h2><ul>
<li>存储分配和回收：按照一定的策略为并发进程分配内存空间，并回收系统或用户释放的空间。</li>
<li>地址变换：将程序地址空间中使用的逻辑地址变换成主存中的地址<ul>
<li>程序加载(装入)时的重定位技术</li>
<li>运行时硬件和软件的地址变换机构和技术</li>
</ul>
</li>
<li>存储共享和保护：<ul>
<li>代码和数据的共享，提高内存的利用率</li>
<li>限制只在各自的存储区域内操作，互不干扰</li>
</ul>
</li>
<li>存储器扩充方式（通过内、外存之间交换程序或数据段，即涉及到内外存数据传输的控制）<ul>
<li>覆盖 </li>
<li>交换</li>
<li>请求调入 / 预调入</li>
</ul>
</li>
</ul>
<h2 id="存储的分配与回收"><a href="#存储的分配与回收" class="headerlink" title="存储的分配与回收"></a>存储的分配与回收</h2><p>涉及以下数据结构和策略</p>
<ul>
<li>分配结构：登记内存使用情况，例如内存空闲区表、空闲区队列等。</li>
<li>放置策略：即选择内存空闲区的策略。</li>
<li>交换策略：确定把内存中的哪些程序段和数据段调出内存，以便腾出足够的空间。</li>
<li>调入策略：确定外存中的程序段和数据段什么时间、按什么样的控制方式（内外存数据传输控制方式）调入内存。</li>
<li>回收策略：包括回收的时机，及对所回收的内存空闲区和已存在的内存空闲区的调整</li>
</ul>
<p>存储分配的方式</p>
<ul>
<li>直接分配：程序员在编写程序时，或编译程序对源程序进行编译时，直接使用实际的存储地址。<ul>
<li>前提：事先确定一个作业在主存中的位置</li>
<li>缺点：存储空间的利用率不高，且不便</li>
</ul>
</li>
<li>静态分配：程序装入内存时才确定在内存中的位置，且在其整个运行期间不能在内存中移动，也不能再申请内存空间。<ul>
<li>前提：程序装入内存时必须分配所要求的全部存储量，且退出前不释放</li>
<li>缺点：在多道程序系统中不能有效地共享存储器资源</li>
</ul>
</li>
<li>动态分配：作业装入内存时才确定它们在内存中的位置，但在其整个运行期间可以再申请内存空间，也可在内存中移动。一个程序已占有的存储区不再需要时，可以归还给系统。</li>
</ul>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位（地址映射）：在可执行文件装入时需要解决可执行文件中地址（包含指令和数据的地址）和内存地址的对应。</p>
<p>重定位/地址映射就是建立虚实地址的对应关系。有三种实现方式：</p>
<ul>
<li>绝对装入：编程或编译时确定地址映射关系</li>
<li>静态地址重定位（静态地址映射）：程序执行前，由装入程序负责完成地址映射</li>
<li>动态地址重定位（动态地址映射）：处理机执行程序指令时，由动态地址变换机构（硬件）自动完成地址映射</li>
</ul>
<h2 id="内存信息的共享与保护"><a href="#内存信息的共享与保护" class="headerlink" title="内存信息的共享与保护"></a>内存信息的共享与保护</h2><p>存储保护的目的</p>
<ul>
<li>保护系统程序区不被用户侵犯（有意或无意的）</li>
<li>不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）</li>
</ul>
<p>存储保护类型</p>
<ul>
<li>界限保护（上界/下界寄存器或基址/限长寄存器）<ul>
<li>每个进程都有自己独立的进程空间，如果一个进程在运行时所产生的地址在其地址空间之外，则发生地址越界</li>
<li>当程序要访问某个内存单元时，由硬件检查是否允许，如果允许则执行，否则产生地址越界中断，由操作系统进行相应处理。</li>
</ul>
</li>
<li>访问方式保护（保护键）<ul>
<li>对于允许多个进程共享的存储区域，每个进程都有自己的访问权限。如果一个进程对共享区域的访问违反了权限规定，则发生操作越权(即读写保护)。</li>
<li>为每一个被保护内存区域指定保护键和若干禁止的访问方式，同时进程指定保护键开关。如果访问时键值不匹配而且是被禁止的访问方式，则产生访问出错中断。</li>
</ul>
</li>
</ul>
<p>上下界保护法</p>
<ul>
<li>下界寄存器：存放程序装入内存后的起始地址（首址）</li>
<li>上界寄存器： 存放程序装入内存后的末地址</li>
<li>判别式：下界寄存器 ≤ 被访问地址 ≤ 上界寄存器</li>
</ul>
<p>基址、限长寄存器保护法</p>
<ul>
<li>判别式：逻辑地址≤限长寄存器</li>
</ul>
<p>上下界保护和基址、限长寄存器存储保护技术的区别</p>
<ul>
<li>寄存器的设置不同</li>
<li>判别式中用的判别项及判别条件不同<ul>
<li>上下界寄存器保护法用转换后的物理地址进行判别</li>
<li>基址、限长寄存器保护法直接用程序的逻辑地址</li>
</ul>
</li>
<li>上下界寄存器保护法浪费的CPU时间相对要多些</li>
</ul>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>虚拟存储器概念</p>
<ul>
<li>出发点：进程的执行过程中，其大部分程序和数据不常被访问</li>
<li>虚拟存储器（虚存/虚拟存储技术）：为用户提供一种不受物理存储器结构和容量限制的存储技术。<ul>
<li>使得用户编程时不需要考虑物理内存的结构和容量</li>
<li>每个进程都拥有自己的虚存，且虚存大小不受实际物理存储器的限制</li>
</ul>
</li>
<li>现代计算机操作系统都采用了虚拟存储技术，虚拟存储器是存储管理的核心概念。</li>
<li>虚拟存储器的物质基础：<ul>
<li>两级存储结构：内存和外存储器</li>
<li>地址变换机构：实现逻辑地址到物理地址的转换</li>
</ul>
</li>
</ul>
<p>虚拟存储器的原理</p>
<ul>
<li>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分读入到内存，便可让程序开始执行（程序的一部分在内存就可执行）。</li>
<li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存，则由处理器通知操作系统将相应的程序段或数据调入到内存，然后继续执行程序。</li>
<li>另一方面，将内存中暂时不使用的程序段或数据调出保存在外存上，从而腾出空间存放将要装入的程序及数据。</li>
</ul>
<p>虚拟存储器的特征</p>
<ul>
<li>虚拟性<br>能从逻辑上扩充内存容量，使用户“看到”的内存容量远大于实际大小</li>
<li>离散分配<br>内存空间可非连续分配</li>
<li>部分分配<br>一个作业可被分成多次调入内存运行</li>
<li>多次对换<br>允许在作业的运行过程中进行换进、换出</li>
</ul>
<p>虚拟存储器的容量限制</p>
<ul>
<li>用户的地址空间大小受地址字长的限制：机器指令中表示地址的二进制位数是有限的，如32位或64位。若地址字长为32位，则地址空间最大是4G</li>
<li>虚拟存储器总容量：不超过物理内存和外存交换区容量之和</li>
<li>外存容量：一般硬盘作为外存，硬盘容量有限，所以用户的地址空间小于硬盘中作业的存放空间</li>
</ul>
<p>虚拟存储技术的分类（根据地址空间结构的不同分为三类）</p>
<ul>
<li>页式管理</li>
<li>段式管理</li>
<li>段页式管理</li>
</ul>
<h2 id="内外存数据传输的控制"><a href="#内外存数据传输的控制" class="headerlink" title="内外存数据传输的控制"></a>内外存数据传输的控制</h2><ul>
<li>由应用程序控制<ul>
<li>覆盖 Overlay</li>
</ul>
</li>
<li>由OS控制<ul>
<li>交换 Swapping（整个进程空间）</li>
<li>虚拟存储 Virtual store（部分进程空间）<ul>
<li>请求调入 On demand </li>
<li>预调入 On prefetch</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>覆盖（overplay）</p>
<ul>
<li>原理：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。<ul>
<li>将程序的必要部分（常用功能）的代码和数据常驻内存</li>
<li>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要时才装入到内存</li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖(即不同时用的模块可共用一个分区)</li>
<li>可与分区存储管理配合使用</li>
</ul>
</li>
<li>缺点：<ul>
<li>用户负担大（要求用户清楚地了解程序的结构，并指定各程序段调入内存的先后次序）</li>
<li>程序段的最大长度仍受内存容量限制</li>
<li>不能实现虚拟存储器</li>
</ul>
</li>
</ul>
<p>交换（swapping）</p>
<ul>
<li>原理：将暂时不能执行的程序送到外存中，从而获得空闲内存空间来装入新程序。<ul>
<li>程序暂时不能执行的可能原因：处于阻塞状态，低优先级（确保高优先级程序执行）；</li>
<li>交换单位为整个进程的地址空间</li>
<li>常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。</li>
</ul>
</li>
<li>换出swap out<br>暂停内存中进程的执行，将其整个地址空间保存到外存的交换区中</li>
<li>换入swap in<br>将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列</li>
</ul>
<p>虚拟存储（virtual store）</p>
<ul>
<li>请求调入 On demand<br>请求调入方式是在程序执行时，如果所要访问的程序段或数据段不在内存中，则操作系统自动地从外存将有关的程序段和数据段调入内存。</li>
<li>预调入 On prefetch<br>预调入方式则是由操作系统预测在不远的将来会访问到的那些程序段和数据段部分，并在它们被访问之前系统选择适当的时机将它们调入内存。</li>
</ul>
<h1 id="存储管理基本技术"><a href="#存储管理基本技术" class="headerlink" title="存储管理基本技术"></a>存储管理基本技术</h1><h2 id="分区管理基本原理"><a href="#分区管理基本原理" class="headerlink" title="分区管理基本原理"></a>分区管理基本原理</h2><p>分区（partition）</p>
<ul>
<li>原理：把内存分为一些大小相等或不等的分区，除操作系统占用一个分区外，其余分区用来存放进程的程序和数据。</li>
<li>特点：适用于多道程序系统和分时系统（最简单）<ul>
<li>支持多个程序并发执行</li>
<li>难以进行内存分区的共享。</li>
</ul>
</li>
<li>问题：可能存在内碎片和外碎片。<ul>
<li>内碎片：被占用分区之内未被利用的空间</li>
<li>外碎片：被占用分区之间难以利用的空闲分区（通常是小空闲分区）。</li>
</ul>
</li>
</ul>
<p>按分区的时机，分区管理可以分为：</p>
<ul>
<li>固定分区法：系统初始化时将内存固定地划分区域</li>
<li>动态分区法：在作业的处理过程中划分区域（根据需要确定大小）</li>
</ul>
<h3 id="固定分区法"><a href="#固定分区法" class="headerlink" title="固定分区法"></a>固定分区法</h3><p>原理：</p>
<ul>
<li>分区大小可以相等，也可以不相等<br>分区大小不等：<ul>
<li>多个小分区、适量的中等分区、少量的大分区</li>
<li>根据程序的大小，分配当前空闲的、适当大小的分区</li>
</ul>
</li>
<li>分区个数不变，大小不变</li>
</ul>
<p>内存分配管理</p>
<ul>
<li>数据结构：分区说明表（分区号、分区大小、起始地址、分区状态）</li>
<li>由内存分配程序检索分区说明表，找到符合要求的分区。</li>
</ul>
<p>存储保护与重定位（地址转换）</p>
<ul>
<li>每个分区（一道程序）对应一对界地址寄存器：上/下限寄存器。</li>
<li>采用静态重定位方式，即由链接/装入程序完成。</li>
</ul>
<p>优点：简单，要求的硬件支持少；<br>缺点：存在大的碎片，主存利用率低。</p>
<h3 id="动态分区法"><a href="#动态分区法" class="headerlink" title="动态分区法"></a>动态分区法</h3><ul>
<li>思想<ul>
<li>位置和大小都不固定，应作业的要求而设置</li>
</ul>
</li>
<li>数据结构<ul>
<li>空闲分区表(可用表)</li>
<li>空闲分区链(自由链)</li>
<li>请求表：描述请求内存资源的作业或进程号及所请求的内存大小</li>
</ul>
</li>
<li>系统初启时，操作系统占用内存的一部分（从低地址开始），剩下的部分作为一个空闲区。当一个用户程序（作业、进程）调入内存时，把这个空闲区的低地址部分区域分配给它</li>
</ul>
<h2 id="分区的分配与回收"><a href="#分区的分配与回收" class="headerlink" title="分区的分配与回收"></a>分区的分配与回收</h2><p>内存分配程序包括两个函数</p>
<ul>
<li>分配一个分区<br>（返回：成功时为分区的首地址，失败时为0 ）</li>
<li>释放一个分区<br>（返回：无）</li>
</ul>
<p>当进程需要一个大小为size的内存时，可以通过系统调用向系统申请。</p>
<h3 id="固定分区的分配与回收"><a href="#固定分区的分配与回收" class="headerlink" title="固定分区的分配与回收"></a>固定分区的分配与回收</h3><p>分配算法：存储管理程序根据请求表查询分区说明表，从中找出一个满足要求的空闲分区，并将其分配给申请者<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%862.PNG" alt="存储管理2"></p>
<p>回收算法：将对应的分区状态置为“未使用”</p>
<h3 id="动态分区的分配与回收"><a href="#动态分区的分配与回收" class="headerlink" title="动态分区的分配与回收"></a>动态分区的分配与回收</h3><p>动态分区的分配算法：</p>
<ul>
<li>从可用表/自由链中找到一个足以容纳该作业的可用空白区</li>
<li>若这个空白区比所需求大，则将它分成2个部分：一部分成为已分配区，剩下部分仍为空白区</li>
<li>修改可用表或自由链，并回送一个所分配区的序号或该分区的始址</li>
</ul>
<p>动态分区的回收算法</p>
<ul>
<li>检查回收的分区是否与空白区邻接，如有则加以合并，使之成为一个连续的大空白区；</li>
<li>修改可用表或自由链。</li>
</ul>
<p>寻找合适的空闲区是关键。通常有3种方法</p>
<ul>
<li>最先适应法(first-fit)：按分区起始地址的递增次序，从头查找，找到符合要求的第一个分区。</li>
<li>最佳适应法(best-fit)：按分区大小的递增次序，查找，找到符合要求的第一个分区。</li>
<li>最坏适应法(worst-fit)：按分区大小的递减次序，从头查找，找到符合要求的第一个分区。</li>
</ul>
<p>三种算法的比较</p>
<ul>
<li>最先（首次）适应算法<ul>
<li>尽可能地利用了低地址空间，从而保证高地址有较大的空闲区来放置要求内存较多的进程或作业。</li>
<li>该算法的分配和释放的时间性能较好</li>
</ul>
</li>
<li>最佳适应算法<ul>
<li>利用最接近于所要求的内存大小。若存储空间中有正好等于所要求大小的空白区，则必然被选中。</li>
<li>由于空白区一般不可能正好和要求的的相等，这往往使剩下的空白区都比较小，形成“碎片”。</li>
<li>寻找一个较大空白区时，要花费较多的时间；回收一个分区时，为了把它插入到空白区链中合适的位置上开销较大。</li>
</ul>
</li>
<li>最坏适应算法<ul>
<li>避免了空闲区越分越小、留下碎片的问题，即每次分配时，总是将最大的空闲区切去一部分分配给请求者（使分配后的剩余部分可能仍是一个较大的空闲区，仍能进行再分配）。</li>
</ul>
</li>
</ul>
<p>碎片和紧缩技术</p>
<ul>
<li>碎片（内/外零头）：内存中无法利用的小空闲区</li>
<li>内存紧缩(紧凑/拼接技术compaction)：将各占用分区向内存一端移动，使各空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。<ul>
<li>紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时</li>
<li>额外开销<ul>
<li>内存搬移占用CPU时间</li>
<li>程序”浮动”，其重定位需要硬件支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他问题讨论"><a href="#其他问题讨论" class="headerlink" title="其他问题讨论"></a>其他问题讨论</h3><p>关于内存扩充</p>
<ul>
<li>可使用覆盖或交换技术来扩充内存</li>
</ul>
<p>关于虚拟存储器的实现</p>
<ul>
<li>分区式管理无法实现虚拟存储器</li>
<li>用户进程受分区大小或内存可用空间的限制</li>
</ul>
<p>关于地址变换和内存保护</p>
<ul>
<li>静态 / 动态地址重定位技术都可采用<ul>
<li>动态分区时应采用动态地址重定位，因为分区大小不固定，且空闲区的拼接会移动内存中的程序和数据</li>
</ul>
</li>
<li>动态地址重定位时，每个分区需要硬件寄存器支持</li>
<li>保护键法和界限寄存器法都可用保护分区</li>
</ul>
<p>分区存储管理的主要优缺点</p>
<ul>
<li>优点：<ul>
<li>实现了多个作业或进程对内存的共享</li>
<li>要求的硬件支持少，管理算法简单，易实现</li>
</ul>
</li>
<li>缺点：<ul>
<li>内存利用率不高，主要是碎片问题</li>
<li>作业的大小或进程大小受分区大小限制</li>
<li>难以实现各分区间的信息共享</li>
</ul>
</li>
</ul>
<h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>分页的概念</p>
<ul>
<li>逻辑空间分页：程序地址空间分成大小相等的页（页面的大小为2n ，通常为1KB，2KB，nKB等）。每页都有一个页号，从0开始编排。</li>
<li>内存空间分块：把内存也按页的大小分成内存块或页面，同样从0开始编排。</li>
<li>内存分配原则：当一个用户程序装入内存时，以页为单位进行分配，并且一个进程的若干页可分别装入物理上不相邻的内存块中。<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%863.PNG" alt="存储管理3"></li>
</ul>
<p>逻辑地址（虚地址）的表示：<br>在分页存储管理中，用户程序中的逻辑地址包括页号和页内地址（页内位移）。<br>如果给定页面大小为L，逻辑地址是A，则页号和页内位移可按下式计算：P=INT [ A/L]，d=A MOD L。</p>
<p>页表：<br>分页系统中作业或进程的各页可以离散地装入内存的任何空闲块中。因此，连续的作业的页号，可以对应于不连续的块号。<br>页表是页式存储管理的数据结构，它包括用户程序空间的页面与内存块的对应关系、页面的存储保护和存取控制方面的信息。<br>页表的作用：进行页号到块号的映射<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%864.PNG" alt="存储管理4"></p>
<p>页式地址映射<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%865.PNG" alt="存储管理5"><br>虚地址以十进制数给出：</p>
<ul>
<li>页号＝INT[虚地址/页大小]</li>
<li>位移量＝虚地址 mod 页大小</li>
<li>根据题意产生页表</li>
<li>以页号查页表，得到对应的内存块号</li>
<li>内存地址＝块号×页大小＋位移量</li>
</ul>
<h2 id="请求页式存储管理"><a href="#请求页式存储管理" class="headerlink" title="请求页式存储管理"></a>请求页式存储管理</h2><p>请求分页的实现思想</p>
<ul>
<li>和纯分页的相同点：逻辑空间分页，内存空间分块。</li>
<li>和纯分页的不同点：请求分页技术当一个用户程序要调入内存时，不是将该程序全部装入内存，而是只装入部分页到内存，就可启动程序运行，在运行的过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将在外存相应的页调入内存，该程序继续运行。</li>
</ul>
<p>数据结构<br>为了实现请求分页技术，页表应增加相应的内容，反映该页是否在内存，在外存的位置，在内存的时间的长短等。</p>
<ul>
<li>中断位（状态位）：表示该页是否在内存（1表示不在）</li>
<li>外存始址：用于指出该页在外存上的地址</li>
<li>引用位：表示最近是否有进程访问过（1表示有）</li>
<li>修改位： 表示该页调入内存后是否有修改（1表示修改过）<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%866.PNG" alt="存储管理6"></li>
</ul>
<p>调入策略</p>
<ul>
<li>预调<br> 系统根据作业（进程）运行的情况，预测哪些页将要运行，在其运行之前先行调入内存（系统很难完全预计作业的运行情况，因此难以实现）。</li>
<li>请调<br> 进程在执行的过程中，发现要执行的程序或要处理的数据不在内存时，产生缺页中断（此时用户进程被中断，转OS的调页程序把外存中相应的页面调入内存）。</li>
</ul>
<p>淘汰策略：<br>OS的调页程序把外存上的页调入到内存时，如果此时内存无空闲块，必须把已在内存中的某一页淘汰掉。用来选择淘汰哪一页的规则叫置换算法。<br>刚被淘汰出去的页，不久又要访问，而调入不久又被淘汰，然后又要访问，又调入，如此反复，使得系统把大部分时间开销在了页面的调入和调出上的现象——抖动、颠簸<br>评价指标：缺页次数和缺页率（缺页率为缺页次数与总访问次数之比）</p>
<p>请求页式存储管理流程图<br><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%867.PNG" alt="存储管理7"></p>
<p>请求页式管理中常见的置换算法有4种：<br>(1) 随机淘汰算法<br>(2) 轮转法（RR）和先进先出(FIFO)<br>(3) 最近最久未使用页面置换算法LRU（Least Recent Used）<br>(4) 理想型淘汰算法OPT（Optimal Replacement Algorithm）</p>
<p>随机淘汰算法：<br>当无法确定哪些页被访问的概率较低时，随机地选择某个用户的页并将其换出。（通常：选出的被淘汰的页面，应该是被访问概率最低的页）</p>
<p>轮转法和先进先出法：</p>
<ul>
<li>轮转法：循环换出内存可用区内一个可以被换出的页，无论该页是刚被换进或已换进内存很长时间。</li>
<li>FIFO法：选择在内存驻留时间最长的页将其淘汰。</li>
<li>FIFO和RR内存利用率低的原因<br>两种算法都是基于处理器按线性顺序访问地址空间这一假设。<ul>
<li>事实上，许多时候，处理器不是按线性顺序访问地址空间的。例如，执行循环结构的程序段</li>
<li>那些在内存中停留时间最长的页往往可能也是经常被访问的页。尽管这些页变“老”了。 但它们被访问的概率仍然很高。</li>
</ul>
</li>
<li>FIFO的Belady现象<ul>
<li>正常情况：对于任一作业或进程，如果给它分配的内存块数越接近于它所要求的页面数，则发生缺页的次数会越少</li>
<li>Belady现象：使用FIFO算法时，在未给进程或作业分配足够它所需要的块数时，有时会出现分配的块数增多，缺页次数反而增加的现象</li>
</ul>
</li>
</ul>
<p>最近最久未使用页面置换算法</p>
<ul>
<li>基本思想：<ul>
<li>当需要淘汰某一页时，选择离当前时间最近的一段时间内最久没有使用过的页先淘汰。即当需要淘汰一页时，选择最长时间未使用的页。</li>
</ul>
</li>
<li>基于假设：<ul>
<li>如果某页被访问，它可能马上还要被访问</li>
<li>如果某页长时间未被访问，它可能最近也不可能被访问。</li>
</ul>
</li>
<li>算法的实现（软件）：<ul>
<li>为每页设置一个特定的单元，用于记录自上次访问以来所经历的时间t，当需要置换一页时，选择t最大的淘汰。</li>
</ul>
</li>
<li>LRU的近似算法<ul>
<li>最不经常使用页面淘汰算法LFU<ul>
<li>基本思想：需要淘汰某一页时，首先淘汰到当前时间为止，被访问次数最少的那一页</li>
<li>算法的实现：修改页表<br>在页表中给每一页增设一个访问计数器。每当该页被访问时，访问计数器加1。<br>发生缺页中断时，淘汰计数值最小的那一页，并将其计数器清0。</li>
</ul>
</li>
<li>最近没有使用页面淘汰算法NUR<ul>
<li>基本思想：需要淘汰某一页时，从那些最近一个时期未被访问的页中任选一页淘汰。</li>
<li>算法的实现：修改页表<br>在页表中增设一个访问位，当某页被访问时，访问位置1；否则，访问位置0。系统周期性地对所有访问位清0。<br>当需要淘汰一页时，从那些访问位为0的页中选一页进行淘汰。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="页的存储保护"><a href="#页的存储保护" class="headerlink" title="页的存储保护"></a>页的存储保护</h2><p>页式管理可以为内存提供2种方式的保护：</p>
<ul>
<li>地址越界保护<br>若0≤页号＜用户程序的总页数，则访问合法，否则访问越界。</li>
<li>存储控制保护<br>在页表中增加存取控制位，表示该页的存取控制权限，如r表示可读，w表示可读可写，e表示可执行。当有一程序访问该页时，系统就按存取控制位设置的权限实施存取控制。</li>
</ul>
<h2 id="页式存储管理的优缺点"><a href="#页式存储管理的优缺点" class="headerlink" title="页式存储管理的优缺点"></a>页式存储管理的优缺点</h2><p>优点：</p>
<ul>
<li>有效地解决了碎片问题（不要求连续存放）</li>
<li>支持虚存（内存、外存统一管理）</li>
</ul>
<p>缺点：</p>
<ul>
<li>要有相应的硬件支持：地址变换机构，缺页中断的产生</li>
<li>增加了系统开销：处理缺页中断</li>
<li>可能产生抖动现象，若请求调页的算法不当</li>
<li>存在“内碎片”问题：最后一页内总有部分空间得不到利用。</li>
<li>不利于程序和数据的共享</li>
</ul>
<h1 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分段：<br>一个用户程序往往由几个程序段（主程序、子程序和函数）所组成，把程序按内容或过程（函数）关系分段，每段有自己的名字（段号）。每个段都从0开始编址，采用一段连续的地址空间。各段的长度可以不等。</p>
<p>段式管理的程序地址结构</p>
<ul>
<li>段式管理把二维虚拟地址空间设计成段号S与段内相对地址W。</li>
<li>段式虚拟地址空间包括：段号S ：段内地址W</li>
<li>每个段定义一组逻辑上完整的程序或数据</li>
<li>段号之间无顺序关系</li>
<li>段长不固定（根据需要，段长可动态增长）</li>
</ul>
<p>段式管理的内存分配思想</p>
<ul>
<li>段式管理以段为单位分配内存<ul>
<li>每段分配一个连续的内存区</li>
<li>同一进程所包含的各段之间不要求连续。</li>
</ul>
</li>
<li>只把那些经常访问的段驻留内存，而把那些将来一段时间内不被访问的段放入外存，等需要时再调入内存中</li>
<li>通过地址映射机构把段式虚拟地址转换成实际的内存物理地址</li>
</ul>
<p>段表和段表地址寄存器</p>
<ul>
<li>段式管理程序在进行初始内存分配之前，为每一个作业或进程建立一个段表，以实现动态地址变换、缺段中断处理及存储保护等。<ul>
<li>段式管理通过段表进行内存管理</li>
<li>段表通常存放在内存的固定区域</li>
</ul>
</li>
<li>为了方便找到所运行进程的段表，系统建立一个段表地址寄存器：段表在内存的起始地址和段表的长度</li>
</ul>
<p>分页和分段的异同之处</p>
<ul>
<li>相同点：在内存中都不是整体连续，且均通过地址映射机构将逻辑地址映射到物理内存。</li>
<li>不同点：<ul>
<li>页是信息的物理单位。用户不需要把程序分页，完全是系统管理的要求。<br>段是信息的逻辑单位。每一段在逻辑上是相对完整的一组信息。分段更好地满足了用户的需求。</li>
<li>页的大小是固定的，且在同一系统中大小相等。<br>段的大小因段而异，取决于用户编写的程序。</li>
<li>分页的作业地址空间是一维的。<br>分段的作业地址空间是二维的。</li>
</ul>
</li>
</ul>
<h2 id="段式存储管理的实现原理"><a href="#段式存储管理的实现原理" class="headerlink" title="段式存储管理的实现原理"></a>段式存储管理的实现原理</h2><p>段式管理的内存分配与释放</p>
<ul>
<li>内存分配与释放在作业或进程的执行过程中动态进行</li>
<li>内存分配分两种情况：<ul>
<li>有足够空闲区时进行分配：可采用动态分区管理的分配算法（最先 / 最佳 / 最坏适应法）</li>
<li>没有足够空闲区时淘汰内存中一个或几个段：可采用动态页式管理的淘汰算法（FIFO淘汰算法、LRU及其近似算法）</li>
</ul>
</li>
<li>内存回收：可采用动态分区管理的内存回收方法（内存拼接）</li>
<li>除了段的初始分配之外，段的动态分配是在处理器所要访问的指令和数据不在内存时产生缺段中断的情况下发生的。<br>段的淘汰或置换实际上是缺段中断处理过程的一部分。</li>
</ul>
<p>段式管理程序进行地址变换的步骤:</p>
<ol>
<li>把该进程的段表始址放入段表地址寄存器</li>
<li>访问段表地址寄存器，得到该进程的段表始址，从而可开始访问段表</li>
<li>由虚地址中的段号S为索引，查找段表</li>
<li>若该段在内存，则判断其存取控制方式是否有错和段内位移是是否超过段长，若都正确，则从段表相应表目中查出该段在内存的起始地址，并将其和段内相对地址W相加，从而得到实际内存地址</li>
<li>若该段不在内存，则产生缺段中断将CPU控制权交给内存分配程序</li>
</ol>
<p>段式管理时的地址变换过程也必须经过二次以上的内存访问（与页式管理相同）</p>
<ol>
<li>首先访问段表以计算得到待访问指令或数据的物理地址</li>
<li>然后访问物理地址上的指令或数据</li>
</ol>
<h2 id="段的共享和保护"><a href="#段的共享和保护" class="headerlink" title="段的共享和保护"></a>段的共享和保护</h2><p>段的共享</p>
<ul>
<li>段是按逻辑意义来划分的，因此可以按段名访问程序段或数据段。</li>
<li>如果进程或作业需要共享内存中的某程序段或数据段，只要使用相同的段名，在段表中填入已在内存中的段的起始地址，并置以适当的读写控制权，就可以共享一个逻辑上完整的内存段信息。</li>
</ul>
<p>段的保护措施：</p>
<ul>
<li>段的越界保护：利用段表和段长来实现</li>
<li>存权的控制：在段表的“存取方式”中设置权限，如R、W、E等</li>
</ul>
<h2 id="段式存储管理的优缺点"><a href="#段式存储管理的优缺点" class="headerlink" title="段式存储管理的优缺点"></a>段式存储管理的优缺点</h2><p>优点：</p>
<ul>
<li>提供内外存统一管理的虚拟存储。</li>
<li>段长可根据需要动态增加（便于增加或吸收新数据的段）</li>
<li>便于具有完整逻辑功能的信息段进行共享。</li>
<li>便于实现动态链接。</li>
</ul>
<p>缺点：</p>
<ul>
<li>要求有更多的硬件支持，提高了成本开销</li>
<li>内存管理上较页式管理要差（对内存空闲区的管理存在与动态分区式管理相同的碎片问题）</li>
<li>分段的最大尺寸受到主存可用空间的限制</li>
<li>淘汰算法选择不当也可能产生抖动现象（和页式管理一样）</li>
</ul>
<h1 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>（1）段页式管理的基本思想<br>用分段方法来管理和分配虚拟存储器，而用分页方法来管理和分配内存（主存储器）<br>一方面，可以保持分段地址空间所带来的优点，如允许段的动态扩展，可实现段的动态链接，段的共享，实施段保护措施等等。另一方面利用页式管理解决主存分区的拼接，辅存的管理以及对分段大小限制等问题。<br>（2）等分内存<br>把整个内存分成大小相等的内存块（内存被划分成若干个页），内存块从0开始依次编号。<br>（3）地址空间分段<br>把用户程序分成若干段，每段有段名。<br>（4）段内分页<br>段内页面的大小与内存块相同，每段都分别从0开始依次编号。<br>虚空间的最小单位是页而不是段，分段大小不再受内存可用区的限制（每段所拥有的程序和数据在内存中可以按页分开存放）<br>（5）逻辑地址的构成<br>逻辑地址由三分部构成：V=（S，P，d）<br>（6）内存分配<br>以页块为单位进行分配<br>（7）段表、页表和段表地址寄存器<br>为了实现从逻辑地址到物理地址的转换：为每个作业或进程建立一张段表<br>          段表中的段长→页表长度<br>          段表中的内存始址→页表始址<br> 每个段拥有一张页表：段内的页号映射为内存中的物理块号。<br> 段表地址寄存器：段表长度和段表起始地址。</p>
<h2 id="段页式管理的地址变换"><a href="#段页式管理的地址变换" class="headerlink" title="段页式管理的地址变换"></a>段页式管理的地址变换</h2><p><img src="http://ofolh8dcq.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%868.PNG" alt="存储管理8"></p>
<h1 id="局部性原理和抖动"><a href="#局部性原理和抖动" class="headerlink" title="局部性原理和抖动"></a>局部性原理和抖动</h1><p>局部性原理</p>
<ul>
<li>实验发现，几乎所有的程序的执行，在一段时间内，CPU总是集中地访问程序中的某个部分而不是随机地对程序的所有部分具有平均访问概率。</li>
<li>是虚拟存储管理的基础</li>
</ul>
<p>抖动 thrashing （颠簸）</p>
<ul>
<li>在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃，这种现象称为颠簸或抖动。</li>
<li>抖动的原因（缺页率或缺段率过高）：<ul>
<li>页面淘汰算法不合理</li>
<li>分配给进程的物理页面数太少</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>《计算机操作系统教程（第3版）》张尧学 史美林 张高 著</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag">#操作系统</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/23/Chrome开发者工具使用方法/" rel="next" title="Chrome开发者工具使用方法">
                <i class="fa fa-chevron-left"></i> Chrome开发者工具使用方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/29/虚拟机安装Linux系统及常用软件/" rel="prev" title="虚拟机安装Linux系统及常用软件">
                虚拟机安装Linux系统及常用软件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/25/存储管理/"
           data-title="存储管理" data-url="http://zlw.poker/2016/12/25/存储管理/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofolh8dcq.bkt.clouddn.com/webwxgetmsgimg.jpg"
               alt="Lewis" />
          <p class="site-author-name" itemprop="name">Lewis</p>
          <p class="site-description motion-element" itemprop="description">Stay hungry,stay foolish</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">79</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lewiszlw" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://facebook.com/100011178331317" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/林伟-张-85b55a12b" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin"></i>
                  
                  Linkedin
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/3152668301" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/tian-qian-zhu-wu-ya" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://shang.qq.com/email/stop/email_stop.html?qq=597422850&sig=a1c657365db7e82805ea4b2351081fc3ebcde159f8ae49b1&tttt=1" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        
		

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://zlwloveyyf.github.io/" title="GiftForMyGirlfriend" target="_blank">GiftForMyGirlfriend</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://gyh.me/" title="GYH-nobystander" target="_blank">GYH-nobystander</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://youngjjj.me/" title="YoungJJJ" target="_blank">YoungJJJ</a>
                </li>
              
            </ul>
          </div>
        
		
		

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储层次结构"><span class="nav-number">1.1.</span> <span class="nav-text">存储层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储管理的功能"><span class="nav-number">1.2.</span> <span class="nav-text">存储管理的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储的分配与回收"><span class="nav-number">1.3.</span> <span class="nav-text">存储的分配与回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定位"><span class="nav-number">1.4.</span> <span class="nav-text">重定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存信息的共享与保护"><span class="nav-number">1.5.</span> <span class="nav-text">内存信息的共享与保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟存储器"><span class="nav-number">1.6.</span> <span class="nav-text">虚拟存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内外存数据传输的控制"><span class="nav-number">1.7.</span> <span class="nav-text">内外存数据传输的控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储管理基本技术"><span class="nav-number">2.</span> <span class="nav-text">存储管理基本技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分区管理基本原理"><span class="nav-number">2.1.</span> <span class="nav-text">分区管理基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区法"><span class="nav-number">2.1.1.</span> <span class="nav-text">固定分区法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区法"><span class="nav-number">2.1.2.</span> <span class="nav-text">动态分区法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区的分配与回收"><span class="nav-number">2.2.</span> <span class="nav-text">分区的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区的分配与回收"><span class="nav-number">2.2.1.</span> <span class="nav-text">固定分区的分配与回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区的分配与回收"><span class="nav-number">2.2.2.</span> <span class="nav-text">动态分区的分配与回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他问题讨论"><span class="nav-number">2.2.3.</span> <span class="nav-text">其他问题讨论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#页式存储管理"><span class="nav-number">3.</span> <span class="nav-text">页式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">3.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求页式存储管理"><span class="nav-number">3.2.</span> <span class="nav-text">请求页式存储管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页的存储保护"><span class="nav-number">3.3.</span> <span class="nav-text">页的存储保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页式存储管理的优缺点"><span class="nav-number">3.4.</span> <span class="nav-text">页式存储管理的优缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#段式管理"><span class="nav-number">4.</span> <span class="nav-text">段式管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段式存储管理的实现原理"><span class="nav-number">4.2.</span> <span class="nav-text">段式存储管理的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段的共享和保护"><span class="nav-number">4.3.</span> <span class="nav-text">段的共享和保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段式存储管理的优缺点"><span class="nav-number">4.4.</span> <span class="nav-text">段式存储管理的优缺点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#段页式管理"><span class="nav-number">5.</span> <span class="nav-text">段页式管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念-1"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段页式管理的地址变换"><span class="nav-number">5.2.</span> <span class="nav-text">段页式管理的地址变换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#局部性原理和抖动"><span class="nav-number">6.</span> <span class="nav-text">局部性原理和抖动</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lewis</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lewiszlw"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  

  

  
  <script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
